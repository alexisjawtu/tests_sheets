<b>Objetivo: la primera version de la wafer sale con la busqueda enumerativa de los 
nodos de empalme con el perfil.</b></br>

<b>CONTINUE HERE</b> 

<ol>

Consequently, we prefer not to use literals (except very obvious ones, such as 0 and 1) in most
places in our code. Instead, we use constants with descriptive names. Non-obvious literals in code
(outside definitions of symbolic constants) are derisively referred to as magic constant. And by the
way, 299792458 is one of the fundamental constants of the universe: the speed of light in vacuum
measured in meters per second. If you didn’t instantly recognize that, why would you expect not to
be confused and slowed down by other literals embedded in code? Avoid magic constants!

To handle cases where the value of a constant that is initialized with a value that is not known at
compile time but never changes after initialization, C++ offers a second form of constant (a const).

[](a){S} | lambda expression | create a function object taking a as an argument (§21.2.3)

An increment can be expressed in at least three ways:

++a
a+=1
a=a+1

Which notation should we use? Why? We prefer the first version, ++a, because it more directly
expresses the idea of incrementing. It says what we want to do (increment a) rather than how to do
it (add 1 to a and then write the result to a). In general, a way of saying something in a program is
better than another if it more directly expresses an idea. The result is more concise and easier for a
reader to understand. If we wrote a=a+1, a reader could easily wonder whether we really meant to
increment by 1. Maybe we just mistyped a=b+1, a=a+2, or even a=a−1; with ++a there are far fewer
opportunities for such doubts. Please note that this is a logical argument about readability and cor-
rectness, not an argument about efficiency. Contrary to popular belief, modern compilers tend to
generate exactly the same code from a=a+1 as for ++a when a is one of the built-in types. Similarly,
we prefer a∗=scale over a=a∗scale.

Uninitialized variables are a common
source of errors.

Programs are usually easier to write and to understand if each function performs a single logical
action.

If you count, you’ll find that we actually achieved quite a lot with rather few features. That’s
the ideal!

        <li>
                nice style!
                Copy the style found in this game engine

    namespace Algo  
    {  
        template<typename RangeType, typename ProjectionType>  
        bool Algo::AllOf  
        (  
            const RangeType & Range,  
            ProjectionType Projection  
        )  
    }
        </li>

       	<li>
              Las clases solo tienen sus cosas.

	      El papel de main() en un programa simple lo toma un **driver**,
	      que gestiona la ejecucion y los envios de sen~ales entre 
	      objetos.
         </li>

         <li> TODO:
                 map<int, list<int>> vert_by_elems;
                 /* lo lleno durante la escritura de outfile ("elements.dat")
                    en la misma recorrida, sin complicarme.
                 */
        </li>

         <li> 
                revisar y borrar sheets/topic
                                 sheets/isolate-1
        </li>
        
        <li>
        		C'omo qued'o finalmente el algoritmo?
        		Est'an los ladrillos divididos en 5?
        		
        			* IMPORTANTE: en el caso notch los prismas comparten puntos interiores
        			* IMPORTANTE: en el caso notch hay prismas que se pueden suprimir porque 
        			              quedan para rellenar espacios muy estrechos. La alternativa
        			              ser'ia tomar los vecinos a ambos lados y dividir en tres 
        			              anchos iguales.
        		
        </li>




        <li>
                de "reverse engineering":
                                            cuál es diam(probe)?

                                            ver la condición de "outside of wafer" que tiene
                                            algo como 

                                                eps fijo, radio(probe) <= 0.1 - eps
        </li>

         <li> 
                 incluir angle_diff en los jsons 21..30
        </li>

        <li>
                Name: change SetParameter with InputCollection class, that first loads
                the input itself.
        </li>

    <li>
	documentar bien esta variable
	int SetParameter::argv_num_of_input;
    </li>

    <li> uniformize the input files, the jsons </li>

    <li> Deshardcodear todo (sobre todo en el cilindro) y usar 'const' como lo sugiere Stroustrup en 5.4 </li>

    <li> hacer que los graficos muestren la lista de sorted_input.json</li>
    <li> 
	En Cylinder.cpp
        el calculo de  "distance(pA, pD)" esta muchas veces repetido!
        poner "dist_AD" transitoriamente
    </li>
    
    <li> 
         hacer que el graficar vaya mostrando lo que hace en cada linea
                > import ...
                > from ... import ...
    </li>
    <li> elegir un metodo ordenado para dibujar tests sin repetir acciones 
         y dejarlo en uso.
    </li>
</ol>

</br>
</br>
</br>


<b>TODO list</b> 
<ol>

<li>Ojo: en las de NOTCH (class 4) parece que se conservan los puntos de la completacion
del notch porque aparecen en mayavi. Hay que borralos para la búsqueda de nodos de empalme?</li>

<li>investigar y desarrollar mi manera economica de cargar data sets en c++ como hacia
    con pd.read_csv etc...
</li>

<li>
    De la documentación: sacar toda la parte de "uso del profiler solito". Ahora va a ser un solo programa.
</li>
<li>
    escribir this -> 
</li>

<li>
    emprolijar la lectura
</li>

<li>
    Make tests and fixed referential outputs of outer part
</li>

<li>
    Haldor Topsøe, Geometric Factors in Four Point Resistivity Measurement , 1966

    https://www.ossila.com/pages/sheet-resistance-theory

    https://www.ossila.com/pages/resources

</li>

<li>
    ver nombres de m'etodos y vars y mejorarlos
    <ol>
        <li>
            methods
        </li>
        <li>
            vars: 
            <ul>
                <li> theta_p <----- probe_rotation_angle (to finish with the confusion </li>
                <li> L1, L2     <----- len_orientflat_1, len_orientflat_2 </li>    
                <li> angle_diff <----- angle_between_flats </li>
                  
            </ul>
        </li>
        <li>
            classes
        </li>
                <li>
                    Names of files 
                </li>
    </ol>
</li>

<li>
    estudiar bien qu'e hace cada cosa
    <ol>
        <li> refactory de cada cosa como me guste a m'i </li>
        <li> eliminate repeated code </li>
        <li> make fuctions to judge the geometrical conditon for the probe and the shape. </li>
    </ol>
</li>
<li>
    try to unify in an Object Oriented way all the things that are split with</br>
<p>
<font face="monospace">

    .                   if (wtype == 1) ...</br>
    .                   if (wtype == 2) ...</br>
</font>
</p>

<li>
there are lots of enumerative parts of main () that should be
the body of a function.
</li>
<li>
study how to use this to enable pi </br>
<p>
<font face="monospace">
    
        >>  constexpr auto γ{"0.577215664901532860606512090082402"sv}; </br>
        3.141592653589793 </br>
        3.14159265358979323846 </br>
        (taken from https://en.cppreference.com/w/cpp/numeric/constants) </br>

</font>
</p>
</li>

<li>
Para despu'es de finalizado el cilindro:
Mandatory args:
    nodes (3D) --para buscar los indices.
    bdr_nodes (2D) y para pasarlos a (3D) +- thickness/2 --para hacer los elems de borde

Intermediate "arg"
    bdr_diags <--- orient_profile_walls() --necesito vertices_by_elements
</li>

<li>
        Prfiler branches:
            main toma * bdr_pts_2D
                      * diagonals \subset {0, 1}^N
                      --asume que el usuario sabe proporcionar las diagonales

            develop toma * bdr_pts_2D
                         * elements
                         * nodes
                         --brute force para determinar la correspondencia entre indices
                           de distintos alcances.

</li>

<li>
usar <valarray> en todos los lugares en donde haya puntos de R3 o R2
</li>

<li>
Really nice! I found something interesting to mix up.
See what is in puesta_a_tierra.pptx, in the electricity course, about the resistivity.
There is even a drawing with four probes. See which application to grounding can I sell
with my wafer.
</li>


</ol>


$ git branch -d isolate-type-1 
warning: deleting branch 'isolate-type-1' that has been merged to
         'refs/remotes/origin/isolate-type-1', but not yet merged to HEAD.
Deleted branch isolate-type-1 (was 8fff3a7).
