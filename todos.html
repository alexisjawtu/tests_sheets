<b>Objetivo: la primera version de la wafer sale con la busqueda enumerativa de los 
nodos de empalme con el perfil.</b></br>

<b>CONTINUE HERE</b> 

<ol>
        <li>
                nice style!
                Copy the style found in this game engine

    namespace Algo  
    {  
        template<typename RangeType, typename ProjectionType>  
        bool Algo::AllOf  
        (  
            const RangeType & Range,  
            ProjectionType Projection  
        )  
    }
        </li>

       	<li>
              Las clases solo tienen sus cosas.

	      El papel de main() en un programa simple lo toma un **driver**,
	      que gestiona la ejecucion y los envios de sen~ales entre 
	      objetos.
         </li>

         <li> TODO:
                 map<int, list<int>> vert_by_elems;
                 /* lo lleno durante la escritura de outfile ("elements.dat")
                    en la misma recorrida, sin complicarme.
                 */
        </li>

         <li> 
                revisar y borrar sheets/topic
                                 sheets/isolate-1
        </li>
        
        <li>
        		C'omo qued'o finalmente el algoritmo?
        		Est'an los ladrillos divididos en 5?
        		
        			* IMPORTANTE: en el caso notch los prismas comparten puntos interiores
        			* IMPORTANTE: en el caso notch hay prismas que se pueden suprimir porque 
        			              quedan para rellenar espacios muy estrechos. La alternativa
        			              ser'ia tomar los vecinos a ambos lados y dividir en tres 
        			              anchos iguales.
        		
        </li>




        <li>
                de "reverse engineering":
                                            cuál es diam(probe)?

                                            ver la condición de "outside of wafer" que tiene
                                            algo como 

                                                eps fijo, radio(probe) <= 0.1 - eps
        </li>

         <li> 
                 incluir angle_diff en los jsons 21..30
        </li>

        <li>
                Name: change SetParameter with InputCollection class, that first loads
                the input itself.
        </li>

    <li>
	documentar bien esta variable
	int SetParameter::argv_num_of_input;
    </li>

    <li> uniformize the input files, the jsons </li>

    <li> Deshardcodear todo (sobre todo en el cilindro) y usar 'const' como lo sugiere Stroustrup en 5.4 </li>

    <li> hacer que los graficos muestren la lista de sorted_input.json</li>
    <li> 
	En Cylinder.cpp
        el calculo de  "distance(pA, pD)" esta muchas veces repetido!
        poner "dist_AD" transitoriamente
    </li>
    
    <li> 
         hacer que el graficar vaya mostrando lo que hace en cada linea
                > import ...
                > from ... import ...
    </li>
    <li> elegir un metodo ordenado para dibujar tests sin repetir acciones 
         y dejarlo en uso.
    </li>
</ol>

</br>
</br>
</br>


<b>TODO list</b> 
<ol>

<li>Ojo: en las de NOTCH (class 4) parece que se conservan los puntos de la completacion
del notch porque aparecen en mayavi. Hay que borralos para la búsqueda de nodos de empalme?</li>

<li>investigar y desarrollar mi manera economica de cargar data sets en c++ como hacia
    con pd.read_csv etc...
</li>

<li>
    De la documentación: sacar toda la parte de "uso del profiler solito". Ahora va a ser un solo programa.
</li>
<li>
    escribir this -> 
</li>

<li>
    emprolijar la lectura
</li>

<li>
    Make tests and fixed referential outputs of outer part
</li>

<li>
    Haldor Topsøe, Geometric Factors in Four Point Resistivity Measurement , 1966

    https://www.ossila.com/pages/sheet-resistance-theory

    https://www.ossila.com/pages/resources

</li>

<li>
    ver nombres de m'etodos y vars y mejorarlos
    <ol>
        <li>
            methods
        </li>
        <li>
            vars: 
            <ul>
                <li> theta_p <----- probe_rotation_angle (to finish with the confusion </li>
                <li> L1, L2     <----- len_orientflat_1, len_orientflat_2 </li>    
                <li> angle_diff <----- angle_between_flats </li>
                  
            </ul>
        </li>
        <li>
            classes
        </li>
                <li>
                    Names of files 
                </li>
    </ol>
</li>

<li>
    estudiar bien qu'e hace cada cosa
    <ol>
        <li> refactory de cada cosa como me guste a m'i </li>
        <li> eliminate repeated code </li>
        <li> make fuctions to judge the geometrical conditon for the probe and the shape. </li>
    </ol>
</li>
<li>
    try to unify in an Object Oriented way all the things that are split with</br>
<p>
<font face="monospace">

    .                   if (wtype == 1) ...</br>
    .                   if (wtype == 2) ...</br>
</font>
</p>

<li>
there are lots of enumerative parts of main () that should be
the body of a function.
</li>
<li>
study how to use this to enable pi </br>
<p>
<font face="monospace">
    
        >>  constexpr auto γ{"0.577215664901532860606512090082402"sv}; </br>
        3.141592653589793 </br>
        3.14159265358979323846 </br>
        (taken from https://en.cppreference.com/w/cpp/numeric/constants) </br>

</font>
</p>
</li>

<li>
Para despu'es de finalizado el cilindro:
Mandatory args:
    nodes (3D) --para buscar los indices.
    bdr_nodes (2D) y para pasarlos a (3D) +- thickness/2 --para hacer los elems de borde

Intermediate "arg"
    bdr_diags <--- orient_profile_walls() --necesito vertices_by_elements
</li>

<li>
        Prfiler branches:
            main toma * bdr_pts_2D
                      * diagonals \subset {0, 1}^N
                      --asume que el usuario sabe proporcionar las diagonales

            develop toma * bdr_pts_2D
                         * elements
                         * nodes
                         --brute force para determinar la correspondencia entre indices
                           de distintos alcances.

</li>

<li>
usar <valarray> en todos los lugares en donde haya puntos de R3 o R2
</li>

<li>
Really nice! I found something interesting to mix up.
See what is in puesta_a_tierra.pptx, in the electricity course, about the resistivity.
There is even a drawing with four probes. See which application to grounding can I sell
with my wafer.
</li>


</ol>


$ git branch -d isolate-type-1 
warning: deleting branch 'isolate-type-1' that has been merged to
         'refs/remotes/origin/isolate-type-1', but not yet merged to HEAD.
Deleted branch isolate-type-1 (was 8fff3a7).
