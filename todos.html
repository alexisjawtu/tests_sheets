<b>Objetivo: la primera version de la wafer sale con la busqueda enumerativa de los 
nodos de empalme con el perfil.</b></br>

<b>CONTINUE HERE</b> 

<ol>
         <li>
              Cambiar los nombres como
                    caseX/result/{elements ===> cylinder_elements}.dat
         </li>
         <li> TODO:
                 map<int, list<int>> vert_by_elems;
                 /* lo lleno durante la escritura de outfile ("elements.dat")
                    en la misma recorrida, sin complicarme.
                 */
        </li>

         <li> 
                revisar y borrar sheets/topic
                                 sheets/isolate-1
        </li>

        <li>
                de "reverse engineering":
                                            cuál es diam(probe)?

                                            ver la condición de "outside of wafer" que tiene
                                            algo como 

                                                eps fijo, radio(probe) <= 0.1 - eps
        </li>

         <li> 
                 incluir angle_diff en los jsons 21..30
        </li>

       <li>
        Parameter::vector<Point> pointlist; no tiene sentido que exista.
        es solo para incluir los bdr_points en 3D y para contar su tamaño
        </li>

        <li>
                Name: change SetParameter with InputCollection class, that first loads
                the input itself.
        </li>
    <li>
    	carefully choose the version of the outer part to put</br>
   	with the inner part in wafer. Should be the version that</br>
    	looks for the corresponding glue vertices by brute force.
    </li>

    <li>
	documentar bien esta variable
	int SetParameter::argv_num_of_input;
    </li>

    <li> uniformize the input files, the jsons </li>

    <li> Deshardcodear todo (sobre todo en el cilindro) y usar 'const' como lo sugiere Stroustrup en 5.4 </li>

    <li> hacer que los graficos muestren la lista de sorted_input.json</li>
    <li> 
	    Hacer un header con las constantes deshardcodeadas, por ejemplo
    	 	* nombres de archivos
    		* valores de parametros
    </li>

    <li> 
	En Cylinder.cpp
        el calculo de  "distance(pA, pD)" esta muchas veces repetido!
        poner "dist_AD" transitoriamente
    </li>
    
    <li> 
         hacer que el graficar vaya mostrando lo que hace en cada linea
                > import ...
                > from ... import ...
    </li>
    <li> elegir un metodo ordenado para dibujar tests sin repetir acciones 
         y dejarlo en uso.
    </li>
</ol>

</br>
</br>
</br>


<b>TODO list</b> 
<ol>

<li>Ojo: en las de NOTCH (class 4) parece que se conservan los puntos de la completacion
del notch porque aparecen en mayavi. Hay que borralos para la búsqueda de nodos de empalme?</li>

<li>investigar y desarrollar mi manera economica de cargar data sets en c++ como hacia
    con pd.read_csv etc...
</li>

<li>
    Esto podria ir despues de tener el m.v.p.
    
    double n;
    std::string line;

    while (std::cout << "Enter a number: " && !(std::cin >> n))
    {
        std::cin.clear();
        std::getline(std::cin, line);
        std::cout << line << "\nI am sorry, but '" << line << "' is not a number\n";
    }
    std::cout << n << "\nThank you for entering the number " << n << '\n';
</li>

<li>
    De la documentación: sacar toda la parte de "uso del profiler solito". Ahora va a ser un solo programa.
</li>
<li>
    escribir this -> 
</li>

<li>
    emprolijar la lectura
</li>

<li>
    Make tests and fixed referential outputs of outer part
</li>

<li>
    Haldor Topsøe, Geometric Factors in Four Point Resistivity Measurement , 1966

    https://www.ossila.com/pages/sheet-resistance-theory

    https://www.ossila.com/pages/resources

</li>

<li>
    ver nombres de m'etodos y vars y mejorarlos
    <ol>
        <li>
            methods
        </li>
        <li>
            vars: 
            <ul>
                <li> theta_p <----- probe_rotation_angle (to finish with the confusion </li>
                <li> L1, L2     <----- len_orientflat_1, len_orientflat_2 </li>    
                <li> angle_diff <----- angle_between_flats </li>
                  
            </ul>
        </li>
        <li>
            classes
        </li>
                <li>
                    Names of files 
                </li>
    </ol>
</li>

<li>
    estudiar bien qu'e hace cada cosa
    <ol>
        <li> refactory de cada cosa como me guste a m'i </li>
        <li> eliminate repeated code </li>
        <li> make fuctions to judge the geometrical conditon for the probe and the shape. </li>
    </ol>
</li>
<li>
    try to unify in an Object Oriented way all the things that are split with</br>
<p>
<font face="monospace">

    .                   if (wtype == 1) ...</br>
    .                   if (wtype == 2) ...</br>
</font>
</p>

<li>
there are lots of enumerative parts of main () that should be
the body of a function.
</li>
<li>
study how to use this to enable pi </br>
<p>
<font face="monospace">
    
        >>  constexpr auto γ{"0.577215664901532860606512090082402"sv}; </br>
        3.141592653589793 </br>
        3.14159265358979323846 </br>
        (taken from https://en.cppreference.com/w/cpp/numeric/constants) </br>

</font>
</p>
</li>

<li>
Para despu'es de finalizado el cilindro:
Mandatory args:
    nodes (3D) --para buscar los indices.
    bdr_nodes (2D) y para pasarlos a (3D) +- thickness/2 --para hacer los elems de borde

Intermediate "arg"
    bdr_diags <--- orient_profile_walls() --necesito vertices_by_elements
</li>

<li>
        Prfiler branches:
            main toma * bdr_pts_2D
                      * diagonals \subset {0, 1}^N
                      --asume que el usuario sabe proporcionar las diagonales

            develop toma * bdr_pts_2D
                         * elements
                         * nodes
                         --brute force para determinar la correspondencia entre indices
                           de distintos alcances.

</li>

<li>
usar <valarray> en todos los lugares en donde haya puntos de R3 o R2
</li>

<li>
Really nice! I found something interesting to mix up.
See what is in puesta_a_tierra.pptx, in the electricity course, about the resistivity.
There is even a drawing with four probes. See which application to grounding can I sell
with my wafer.
</li>


</ol>
